#include "../../Headers/Level/BasicLevel.h"

#include "../../Headers/Actor/Player.h"
#include "../../Headers/Physics/Collider.h"

namespace Engine
{

  BasicLevel::BasicLevel(const sf::Vector2u &LevelSize, const sf::FloatRect &DefaultView, bool showlines, const sf::Vector2f &GridSpacing)
    : LightTexture(std::make_shared<sf::RenderTexture>()),
    SceneBlendTexture(std::make_shared<sf::RenderTexture>()),
    ShowGridLines(showlines), Size(LevelSize), GridBlockSize(GridSpacing), CurrentView(DefaultView),
    Gravity(new ::vec2d)
  {

  }

  BasicLevel::~BasicLevel()
  {
    if (Gravity)
      delete Gravity;
  }

  void BasicLevel::TickUpdate(const double & delta)
  {
    static double cumulative = 0.f;
    cumulative += delta;

    static hres_time_point FrameStart = hres_clock::now();

    double Tick = delta;

    for (auto & obj : Objects) {
      Tick += std::chrono::duration<double, std::milli>(hres_clock::now() - FrameStart).count();
      obj->TickUpdate(Tick);
    }

    if (cumulative > updateInterval) {

      if (DoUpdatePhysics && (LevelObjects.size() > 0 || Segments.size() > 0)) {
        UpdateObjectPhysics();

        for (auto & obj : LevelObjects) {
          obj.second->PhysicsUpdate();
        }
      }

      cumulative = 0.f;
    }

  }

  void BasicLevel::Render(std::shared_ptr<sf::RenderTarget> Target)
  {
    //This function shouldn't ever be called
  }

  void BasicLevel::RenderOnTexture(std::shared_ptr<sf::RenderTexture> Texture)
  {
    sf::View _view;
    _view.setViewport(CurrentView);

    sf::View oldView = Texture->getView();

    Texture->setView(_view);

    SceneBlendTexture->clear(sf::Color::Transparent);

    if (ShowGridLines) {
      for (auto & arr : GridLines)
        Texture->draw(arr);
    }

    for (auto & obj : LevelObjects)
      Texture->draw(obj.second->Sprite);

    //If we are using the editor, draw the meshes too
    //Make this configurable later
#ifdef WITH_EDITOR

    for (auto & obj : LevelObjects) {
      for (auto & collider : obj.second->GetColliders())
        if (collider->GetMesh().lock())
          collider->GetMesh().lock()->draw(*Texture);
    }

    for (auto & seg : Segments)
      seg->draw(*Texture);
#endif

    Texture->setView(oldView);
  }

  void BasicLevel::OnShutDown()
  {
  }

  void BasicLevel::SerializeOut(std::ofstream & out)
  {
  }

  void BasicLevel::SerializeIn(std::ifstream & in)
  {
  }

  void BasicLevel::HandleInputEvent(const UserEvent & evnt)
  {
  }

  void BasicLevel::HandleKeyPress(const sf::Keyboard::Key & key)
  {
  }

  void BasicLevel::HandleKeyRelease(const sf::Keyboard::Key & key)
  {
  }

  void BasicLevel::HandleWindowResized()
  {
  }

  void BasicLevel::LoadLevel(const std::string & lvlfile)
  {
  }

  void BasicLevel::OnBegin()
  {
  }

  void BasicLevel::OnEnd()
  {
  }

  void BasicLevel::SpawnActor(std::shared_ptr<GenericActor> Actor, const sf::Vector2f & Position)
  {
    Actor->SetActorPosition(Position);

    if (!SpawnAutoGeneratedObject(Actor, "Actor")) {
      ERR_STREAM << "Failed to spawn ACTOR" << std::endl;
    }
    else
      Actor->ScriptInit();
  }

  void BasicLevel::SpawnObject(std::shared_ptr<LevelObject> Object, const sf::Vector2f & Position)
  {
  }

  bool BasicLevel::SpawnAutoGeneratedObject(std::shared_ptr<LevelObject> Object, std::string IDPrePend)
  {
    try
    {
      auto _id = GenerateID();
      std::string objid = IDPrePend + std::to_string(_id);
      Object->InternalID = _id;
      Object->ItemID = objid;
      LevelObjects[objid] = Object;

      return true;
    }
    //When we implement logging, we will log the errors here
    catch (IDException &exc)
    {
      exc.AddCause({ ExceptionCause::SpawnFailure });
      exc.AddMessage(EXCEPTION_MESSAGE("Failed to spawn object"));

      return false;
    }
    catch (EngineRuntimeError &err)
    {
      err.AddCause(ExceptionCause::Unknown);
      err.AddMessage(EXCEPTION_MESSAGE("Failed to spawn object - unknown reason"));

      return false;
    }
    catch (std::exception *)
    {
      throw StdException({ ExceptionCause::StdException, ExceptionCause::Unknown }, EXCEPTION_MESSAGE("Exception occurred in standard library - unknown cause"));
      throw;
    }
  }

  void BasicLevel::SpawnBall(char BallType, const sf::Vector2f & InitialPosition, const sf::Vector2f & InitialVelocity, unsigned int Radius, float Mass, float CoeffecientOfRest, const sf::Color & Color)
  {
    //auto ball = BuildBallMesh(BallType, InitialPosition, InitialVelocity, Radius, Mass, CoeffecientOfRest, Color);
    auto Object = std::make_shared<Engine::LevelObject>();
    Object->Size = { __TO_FLOAT__(Radius), __TO_FLOAT__(Radius) };
    Object->Position = InitialPosition;
    MeshType type = (BallType == 'G' ? MeshType::BallGo : MeshType::Ball);
    Object->AddCollider(Collider2D::CreateCircularMesh(type, InitialPosition, InitialVelocity, Radius, Mass, CoeffecientOfRest, Color));
    //Object->ObjectMesh = BuildBallMesh(BallType, InitialPosition, InitialVelocity, Radius, Mass, CoeffecientOfRest, Color);
    if (!SpawnAutoGeneratedObject(Object, "BallMesh")) {
      //Awh, sad
      //for now, print the error, but don't throw an exception
      ERR_STREAM << "Failed to spawn Ball" << std::endl;
    }
  }

  void BasicLevel::SpawnSquare(float radius, float init_rotation, const sf::Vector2f & InitialPosition, const sf::Vector2f & InitialVelocity, float mass, float CoeffOfRest, const sf::Color & Color)
  {
    //auto sq = BuildPolygonMesh(4, radius, 0, InitialPosition, InitialVelocity, mass, CoeffOfRest, Color);
    auto Object = std::make_shared<Engine::LevelObject>();
    Object->Size = { radius, radius };
    Object->Position = InitialPosition;
    MeshType type = MeshType::Polygon;
    Object->AddCollider(Collider2D::CreatePolygonMesh(4, radius, 0, InitialPosition, InitialVelocity, mass, CoeffOfRest, Color));
    //Object->ObjectMesh = BuildPolygonMesh(4, radius, 0, InitialPosition, InitialVelocity, mass, CoeffOfRest, Color);

    if (!SpawnAutoGeneratedObject(Object, "Square")) {
      ERR_STREAM << "Failed to spawn Square" << std::endl;
    }
  }

  void BasicLevel::SpawnRect(float radius, float init_rotation, const sf::Vector2f & InitialPosition, const sf::Vector2f & InitialVelocity, float mass, float CoeffOfRest, const sf::Color & Color)
  {
    //auto sq = BuildPolygonMesh(4, radius, init_rotation, InitialPosition, InitialVelocity, mass, CoeffOfRest, Color);
    std::shared_ptr<Engine::LevelObject> Object = std::make_shared<Engine::LevelObject>();
    Object->Size = { radius, radius };
    Object->Position = InitialPosition;
    Object->AddCollider(Collider2D::CreatePolygonMesh(4, radius, init_rotation, InitialPosition, InitialVelocity, mass, CoeffOfRest, Color));
    //Object->ObjectMesh = BuildPolygonMesh(4, radius, init_rotation, InitialPosition, InitialVelocity, mass, CoeffOfRest, Color);
    if (!SpawnAutoGeneratedObject(Object, "RectMesh")) {
      ERR_STREAM << "Failed to spawn Rect" << std::endl;
    }
  }

  void BasicLevel::SpawnTriangle(float radius, float init_rotation, const sf::Vector2f & InitialPosition, const sf::Vector2f & InitialVelocity, float mass, float CoeffOfRest, const sf::Color & Color)
  {
    std::shared_ptr<Engine::LevelObject> Object = std::make_shared<Engine::LevelObject>();
    Object->Size = { radius, radius };
    Object->Position = InitialPosition;
    Object->AddCollider(Collider2D::CreatePolygonMesh(3, radius, init_rotation, InitialPosition, InitialVelocity, mass, CoeffOfRest, Color));
    //Object->ObjectMesh = BuildPolygonMesh(3, radius, init_rotation, InitialPosition, InitialVelocity, mass, CoeffOfRest, Color);
    if (!SpawnAutoGeneratedObject(Object, "TriMesh")) {
      ERR_STREAM << "Failed to spawn TriMesh" << std::endl;
    }
  }

  void BasicLevel::SpawnNPoly(unsigned int num_sides, float radius, float init_rotation, const sf::Vector2f & InitialPosition, const sf::Vector2f & InitialVelocity, float mass, float CoeffOfRest, const sf::Color & Color)
  {
    //auto poly = BuildPolygonMesh(num_sides, radius, init_rotation, InitialPosition, InitialVelocity, mass, CoeffOfRest, Color);
    std::shared_ptr<Engine::LevelObject> Object = std::make_shared<Engine::LevelObject>();
    Object->Size = { radius, radius };
    Object->Position = InitialPosition;
    Object->AddCollider(Collider2D::CreatePolygonMesh(num_sides, radius, init_rotation, InitialPosition, InitialVelocity, mass, CoeffOfRest, Color));
    //Object->ObjectMesh = BuildPolygonMesh(num_sides, radius, init_rotation, InitialPosition, InitialVelocity, mass, CoeffOfRest, Color);
    if (!SpawnAutoGeneratedObject(Object, "NPolyMesh")) {
      ERR_STREAM << "Failed to spawn NPolyMesh" << std::endl;
    }
  }

  void BasicLevel::SpawnWave(char type, const sf::Vector2i & TopLeftCorner, const sf::Vector2i & BottomRightCorner, float radius, bool IsHard, unsigned int NumWavePts, float ampRight, float waveLenRight, float rFreqRight, float ampLeft, float waveLenLeft, float rFreqLeft, float elev, float airDen, float depth, float fluidDen)
  {

    auto ptr = BuildWaveSegment(type, TopLeftCorner, BottomRightCorner, radius, IsHard, NumWavePts, ampRight, waveLenRight, rFreqRight, ampLeft, waveLenLeft, rFreqLeft, elev, airDen, depth, fluidDen);
    Segments.push_back(ptr);
  }

  void BasicLevel::LoadFromFile(const std::string & file)
  {
  }

  void BasicLevel::LoadAssets(const Json::Value & value)
  {
  }

  void BasicLevel::LoadAudio(const Json::Value & value)
  {
  }

  void BasicLevel::LoadTextures(const Json::Value & value)
  {
  }

  void BasicLevel::LoadTileSheets(const Json::Value & value)
  {
  }

  void BasicLevel::LoadSheet(const Json::Value & value)
  {
  }

  void BasicLevel::LoadAnimations(const Json::Value & value)
  {
  }

  void BasicLevel::UpdateObjectPhysics()
  {
  }

}
